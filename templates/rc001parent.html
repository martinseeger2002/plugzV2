<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC001 Parent Builder</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <h1>RC001 Parent Builder</h1>
    <div id="layersContainer"></div>
    <button class="button" onclick="addLayer()">Add Layer</button>
    <button class="button" onclick="generateOutput()">Generate Output</button>
    <button class="button" onclick="saveState()">Save</button>
    <button class="button" onclick="startOver()">Start Over</button>

    <h2>Output:</h2>
    <div class="output" id="output"></div>

    <!-- Network Selection Dropdown -->
    <label for="networkSelect">Select Network:</label>
    <select id="networkSelect">
        <option value="doge">Doge</option>
        <option value="pepe">Pepe</option>
    </select>

    <script>
        let layers = [];

        // Load saved state from local storage on page load
        window.onload = function() {
            const savedLayers = localStorage.getItem('layers');
            if (savedLayers) {
                layers = JSON.parse(savedLayers);
                layers.forEach((layer, index) => {
                    if (layer) {
                        addLayer(index, layer.layerName);
                        layer.traits.forEach((trait, traitIndex) => {
                            if (trait) {
                                addTrait(index, traitIndex, trait.name, trait.inscriptionId);
                            }
                        });
                    }
                });
            }
        };

        function saveState() {
            const currentState = layers.map((layer, index) => {
                if (layer) {
                    const layerName = document.getElementById(`layerName-${index}`).value;
                    const traits = layer.traits.map((trait, traitIndex) => {
                        if (trait) {
                            const name = document.getElementById(`layerName-${index}-${traitIndex}`).value;
                            const inscriptionId = document.getElementById(`inscriptionId-${index}-${traitIndex}`).value;
                            return { name, inscriptionId };
                        }
                        return null;
                    }).filter(trait => trait !== null);
                    return { layerName, traits };
                }
                return null;
            }).filter(layer => layer !== null);

            localStorage.setItem('layers', JSON.stringify(currentState));
            alert('State saved successfully!');
        }

        function startOver() {
            if (confirm('Are you sure you want to start over? This will delete all current progress.')) {
                localStorage.removeItem('layers');
                layers = [];
                document.getElementById('layersContainer').innerHTML = '';
            }
        }

        function addLayer(index = layers.length, layerName = '') {
            const layerContainer = document.createElement('div');
            layerContainer.className = 'container';
            layerContainer.id = `layer-${index}`;

            layerContainer.innerHTML = `
                <label>Layer Name:</label>
                <input type="text" id="layerName-${index}" placeholder="Layer Name" value="${layerName}">
                <button class="button" onclick="addTrait(${index})">Add Trait</button>
                <button class="button" onclick="removeLayer(${index})">Remove Layer</button>
                <div id="traitsContainer-${index}" class="traitsContainer"></div>
                <label>JSON Input for Traits:</label>
                <textarea id="jsonInput-${index}" placeholder='Enter JSON here'></textarea>
                <button class="button" onclick="addTraitsFromJson(${index})">Add Traits from JSON</button>
            `;

            document.getElementById('layersContainer').appendChild(layerContainer);
            layers[index] = { layerIndex: index, traits: [] };
        }

        function addTrait(layerIndex, traitIndex = layers[layerIndex].traits.length, name = '', inscriptionId = '') {
            const traitsContainer = document.getElementById(`traitsContainer-${layerIndex}`);

            const traitContainer = document.createElement('div');
            traitContainer.className = 'container';
            traitContainer.id = `trait-${layerIndex}-${traitIndex}`;

            const autoGeneratedTraitIndex = `${layerIndex}:${traitIndex.toString().padStart(2, '0')}`;

            traitContainer.innerHTML = `
                <label>Trait Name:</label>
                <input type="text" id="layerName-${layerIndex}-${traitIndex}" placeholder="Trait Name" value="${name}">
                <label>Inscription ID:</label>
                <input type="text" id="inscriptionId-${layerIndex}-${traitIndex}" placeholder="Inscription ID" value="${inscriptionId}">
                <input type="hidden" id="traitIndex-${layerIndex}-${traitIndex}" value="${autoGeneratedTraitIndex}">
                <button class="button" onclick="removeTrait(${layerIndex}, ${traitIndex})">Remove</button>
            `;

            traitsContainer.appendChild(traitContainer);
            layers[layerIndex].traits[traitIndex] = { traitIndex };
        }

        function removeTrait(layerIndex, traitIndex) {
            const traitContainer = document.getElementById(`trait-${layerIndex}-${traitIndex}`);
            traitContainer.remove();

            // Remove the trait from layers data
            layers[layerIndex].traits[traitIndex] = null;
        }

        function removeLayer(layerIndex) {
            const layerContainer = document.getElementById(`layer-${layerIndex}`);
            layerContainer.remove();

            // Remove the layer from layers data
            layers[layerIndex] = null;
        }

        function generateOutput() {
            const jsonData = [];

            layers.forEach((layer, layerIndex) => {
                const layerNameInput = document.getElementById(`layerName-${layerIndex}`);
                const layerName = layerNameInput ? layerNameInput.value : '';

                layer.traits.forEach((trait, traitIndex) => {
                    if (trait) {
                        const inscriptionIdInput = document.getElementById(`inscriptionId-${layerIndex}-${traitIndex}`);
                        const traitIndexInput = document.getElementById(`traitIndex-${layerIndex}-${traitIndex}`);

                        const inscriptionId = inscriptionIdInput ? inscriptionIdInput.value : '';
                        const traitIndexValue = traitIndexInput ? traitIndexInput.value : '';

                        if (inscriptionId) {
                            jsonData.push({
                                inscriptionId,
                                layer: layerName,
                                name: `Trait ${traitIndex + 1}`, // You can customize naming here
                                traitIndex: traitIndexValue
                            });
                        }
                    }
                });
            });

            const networkSelect = document.getElementById('networkSelect');
            const selectedNetwork = networkSelect.value;

            let inscriptionId;
            if (selectedNetwork === 'doge') {
                inscriptionId = "2fd9bda05feb18801319b80f8991be03f581a478bf1bcce130183e12c3f7d43ai0";
            } else if (selectedNetwork === 'pepe') {
                inscriptionId = "dc67ba9af17f32e60e956063838033e6967178b1fe6df80f9fd3c7aab443faedi0";
            }

            const output = `
const jsonData = ${JSON.stringify(jsonData, null, 4)};

// Apply styles dynamically
function applyStyles() {
    const style = document.createElement('style');
    style.textContent = \`
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            width: 100%;
            height: 100%;
        }
    \`;
    document.head.appendChild(style);
}

applyStyles();

// Function to get the 'sn' meta tag content
function getMetaContentByName(name) {
    const meta = document.querySelector(\`meta[name="\${name}"]\`);
    return meta ? meta.getAttribute('content') : null;
}

// Load p5.js and initialize the sketch
function loadP5() {
    const script = document.createElement('script');
    script.src = \`/content/${inscriptionId}\`; // Use the selected network's inscription ID
    script.onload = () => {
        // Create a new p5 instance after p5.js has loaded
        new p5(sketch);
    };
    document.head.appendChild(script);
}

loadP5();

// Define the p5.js sketch using instance mode
function sketch(p) {
    // Variables
    let images = [];
    let showText = false;
    let compositeImage;
    let compositeImageCreated = false;

    // Preload function to load images
    p.preload = function() {
        const sn = getMetaContentByName('sn');
        if (sn) {
            const indices = sn.match(/.{1,2}/g); // Split into two-character pairs
            images = []; // Reset images array
            indices.forEach((index, i) => {
                const traitIndex = \`\${i}:\${index.padStart(2, '0')}\`; // Construct traitIndex with leading zero
                const item = jsonData.find(obj => obj.traitIndex === traitIndex);
                if (item) {
                    const imageUrl = \`/content/\${item.inscriptionId}\`;
                    images[i] = p.loadImage(imageUrl, img => {
                        // Image loaded successfully
                    }, () => {
                        // Error loading image
                        images[i] = null; // Set image to null if failed to load
                    });
                } else {
                    images[i] = null; // Set image to null if not found
                }
            });
        }
    };

    // Setup function for p5.js
    p.setup = function() {
        p.createCanvas(p.windowWidth, p.windowHeight);
    };

    // p5.js draw function
    p.draw = function() {
        p.background(255); // Clear the canvas

        if (images.length > 0) {
            if (!compositeImageCreated) {
                // Create composite image
                let imgWidth = images[0] ? images[0].width : p.width;
                let imgHeight = images[0] ? images[0].height : p.height;

                compositeImage = p.createGraphics(imgWidth, imgHeight);

                // Draw images onto compositeImage, handling null images
                images.forEach(img => {
                    if (img) {
                        compositeImage.image(img, 0, 0, imgWidth, imgHeight);
                    }
                });

                if (showText) {
                    // Overlay text onto compositeImage
                    overlayText(compositeImage);
                }

                compositeImageCreated = true;
            }

            // Draw the composite image onto the canvas, scaling as needed
            let imgAspect = compositeImage.width / compositeImage.height;
            let canvasAspect = p.width / p.height;

            let drawWidth, drawHeight;

            if (imgAspect > canvasAspect) {
                drawWidth = p.width;
                drawHeight = drawWidth / imgAspect;
            } else {
                drawHeight = p.height;
                drawWidth = drawHeight * imgAspect;
            }

            let imgX = (p.width - drawWidth) / 2;
            let imgY = (p.height - drawHeight) / 2;

            p.image(compositeImage, imgX, imgY, drawWidth, drawHeight);
        }
    };

    // Function to handle window resizing
    p.windowResized = function() {
        p.resizeCanvas(p.windowWidth, p.windowHeight);
    };

    // Function to handle mouse clicks
    p.mousePressed = function() {
        if (p.mouseButton === p.LEFT) {
            showText = !showText; // Toggle the showText flag on left click
            compositeImageCreated = false; // Reset to recreate composite image
        }
    };

    // Overlay text onto the composite image
    function overlayText(graphics) {
        // Overlay a semi-transparent black rectangle over the image area
        graphics.fill(0, 150); // Black with transparency
        graphics.rect(0, 0, graphics.width, graphics.height);

        graphics.fill(255); // White text
        graphics.textAlign(p.CENTER, p.CENTER);

        // Get the sn meta tag
        const sn = getMetaContentByName('sn');
        if (sn) {
            const indices = sn.match(/.{1,2}/g);
            const names = indices.map((index, i) => {
                const traitIndex = \`\${i}:\${index.padStart(2, '0')}\`;
                const item = jsonData.find(obj => obj.traitIndex === traitIndex);
                return item ? item.name : '';
            }).filter(name => name !== '');

            // Define labels for each index
            const labels = ['Background Color:', 'Body:', 'Face:'];

            // Create text lines (label and name per trait)
            let textLines = [];
            names.forEach((name, index) => {
                const label = labels[index] || \`Index \${index} Name\`;
                textLines.push(label);
                textLines.push(name);
            });

            // Adjust text size to fit within image area
            const totalLines = textLines.length;
            const linePadding = 2;

            let textSizeValue = (graphics.height - totalLines * linePadding) / (totalLines * 0.2);
            textSizeValue = p.constrain(textSizeValue, 2, 8);
            graphics.textSize(textSizeValue);

            const lineHeight = graphics.textAscent() + graphics.textDescent() + linePadding;
            const totalTextHeight = lineHeight * totalLines;

            // Start Y position for text
            let textY = (graphics.height - totalTextHeight) / 2 + lineHeight / 2;

            // Draw each line of text
            textLines.forEach((line, index) => {
                graphics.text(line, graphics.width / 2, textY + index * lineHeight);
            });
        }
    }
}
        `;
            document.getElementById('output').textContent = output;
        }

        function addTraitsFromJson(layerIndex) {
            const jsonInput = document.getElementById(`jsonInput-${layerIndex}`).value;
            try {
                const traitsArray = JSON.parse(jsonInput);
                traitsArray.forEach(trait => {
                    const traitIndex = layers[layerIndex].traits.length;
                    const traitsContainer = document.getElementById(`traitsContainer-${layerIndex}`);

                    const traitContainer = document.createElement('div');
                    traitContainer.className = 'container';
                    traitContainer.id = `trait-${layerIndex}-${traitIndex}`;

                    const autoGeneratedTraitIndex = `${layerIndex}:${traitIndex.toString().padStart(2, '0')}`;

                    traitContainer.innerHTML = `
                        <label>Trait Name:</label>
                        <input type="text" id="layerName-${layerIndex}-${traitIndex}" value="${trait.name}" placeholder="Trait Name">
                        <label>Inscription ID:</label>
                        <input type="text" id="inscriptionId-${layerIndex}-${traitIndex}" value="${trait.inscriptionId}" placeholder="Inscription ID">
                        <input type="hidden" id="traitIndex-${layerIndex}-${traitIndex}" value="${autoGeneratedTraitIndex}">
                        <button class="button" onclick="removeTrait(${layerIndex}, ${traitIndex})">Remove</button>
                    `;

                    traitsContainer.appendChild(traitContainer);
                    layers[layerIndex].traits.push({ traitIndex });
                });
            } catch (error) {
                alert('Invalid JSON format. Please check your input.');
            }
        }
    </script>
</body>
</html>
