<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doge Terminal</title>
    <style>
        /* Terminal Styles */
        body {
            background-color: #000;
            color: #00FF00;
            font-family: monospace;
            padding: 0;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        #terminal {
            padding: 10px;
            height: 100%;
            box-sizing: border-box;
            overflow-y: auto;
            white-space: pre-wrap;
            position: relative;
        }

        .prompt {
            display: inline;
        }

        .input-line {
            display: flex;
            flex-wrap: wrap;
        }

        input {
            background: none;
            border: none;
            color: #00FF00;
            outline: none;
            font-family: inherit;
            font-size: inherit;
            flex: 1;
        }

        .blinking-cursor {
            display: inline-block;
            width: 10px;
            background-color: #00FF00;
            animation: blink 1s steps(2, start) infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            to {
                visibility: hidden;
            }
        }

        /* Nano Styles */
        .nano-cursor {
            background-color: #00FF00;
            color: #000;
        }
    </style>
</head>
<body>
    <div id="terminal" tabindex="0"></div>

    <script>
        // Terminal Implementation
        class Terminal {
            constructor(element) {
                this.element = element;
                this.promptPath = '/root';
                this.fileSystem = {
                    root: {
                        type: 'directory',
                        children: {
                            'doginals-main': {
                                type: 'directory',
                                children: {
                                    'doginals.js': {
                                        type: 'file',
                                        content: '// Doginals Commands\nconsole.log("Doginals commands");'
                                    },
                                    'readme.md': {
                                        type: 'file',
                                        content: `# Doginals

A minter and protocol for inscriptions on Dogecoin.`
                                    }
                                }
                            },
                            'wallet.json': {
                                type: 'file',
                                content: '{"wallets": []}'
                            }
                        }
                    }
                };
                this.currentDirectory = this.fileSystem.root;
                this.history = [];
                this.historyIndex = -1;
                this.isEditing = false;
                this.editingFile = null;
                this.editingContent = '';
                this.cursorPosition = 0;
                this.init();
            }

            init() {
                this.loadFileSystem();
                this.loadHistory();
                this.printWelcome();
                this.newPrompt();
                // Make the terminal focusable and add key listener
                this.element.setAttribute('tabindex', '0');
                this.element.addEventListener('keydown', (e) => this.handleTerminalKeyDown(e));
            }

            handleTerminalKeyDown(event) {
                if (this.isEditing) {
                    this.handleNanoInput(event);
                }
            }

            loadFileSystem() {
                const data = localStorage.getItem('terminalFileSystem');
                if (data) {
                    try {
                        this.fileSystem = JSON.parse(data);
                        this.currentDirectory = this.getDirectory(this.promptPath);
                    } catch (e) {
                        console.error("Error loading file system from localStorage:", e);
                        this.saveFileSystem();
                    }
                } else {
                    this.saveFileSystem();
                }
            }

            saveFileSystem() {
                try {
                    localStorage.setItem('terminalFileSystem', JSON.stringify(this.fileSystem));
                } catch (e) {
                    console.error("Error saving file system to localStorage:", e);
                }
            }

            loadHistory() {
                const historyData = localStorage.getItem('terminalHistory');
                if (historyData) {
                    this.history = JSON.parse(historyData);
                    this.historyIndex = this.history.length;
                }
            }

            saveHistory() {
                try {
                    localStorage.setItem('terminalHistory', JSON.stringify(this.history.slice(-10)));
                } catch (e) {
                    console.error("Error saving history to localStorage:", e);
                }
            }

            printWelcome() {
                this.printLine("Welcome to the Doge Terminal!");
                this.printLine("Type 'help' to see available commands.");
            }

            newPrompt() {
                if (this.isEditing) {
                    // Do not create a new prompt in nano mode
                    return;
                }
                const promptLine = document.createElement('div');
                promptLine.classList.add('input-line');

                const prompt = document.createElement('span');
                prompt.classList.add('prompt');
                prompt.textContent = `${this.promptPath} $ `;

                const input = document.createElement('input');
                input.setAttribute('type', 'text');
                input.setAttribute('autofocus', 'true');

                const cursor = document.createElement('span');
                cursor.classList.add('blinking-cursor');

                // Event listeners for input
                input.addEventListener('keydown', (e) => this.handleInput(e, input));

                promptLine.appendChild(prompt);
                promptLine.appendChild(input);
                promptLine.appendChild(cursor);
                this.element.appendChild(promptLine);
                input.focus();
                this.element.scrollTop = this.element.scrollHeight;
            }

            handleInput(event, input) {
                if (this.isEditing) {
                    // Ignore input field in nano mode
                    return;
                } else {
                    if (event.key === 'Enter') {
                        const command = input.value.trim();
                        if (command !== '') {
                            this.history.push(command);
                            this.historyIndex = this.history.length;
                            this.saveHistory();
                            this.printLine(`${this.promptPath} $ ${command}`); // Print the command here
                            this.executeCommand(command);
                        }
                        input.disabled = true;
                    } else if (event.key === 'ArrowUp') {
                        if (this.historyIndex > 0) {
                            this.historyIndex--;
                            input.value = this.history[this.historyIndex];
                        }
                    } else if (event.key === 'ArrowDown') {
                        if (this.historyIndex < this.history.length - 1) {
                            this.historyIndex++;
                            input.value = this.history[this.historyIndex];
                        } else {
                            this.historyIndex = this.history.length;
                            input.value = '';
                        }
                    }
                }
            }

            handleNanoInput(event) {
                if (event.ctrlKey && event.key === 'o') {
                    this.saveNanoFile();
                    event.preventDefault();
                    return;
                }
                if (event.ctrlKey && event.key === 'x') {
                    this.exitNano();
                    event.preventDefault();
                    return;
                }
                if (event.key === 'Enter') {
                    this.editingContent = this.editingContent.slice(0, this.cursorPosition) + '\n' + this.editingContent.slice(this.cursorPosition);
                    this.cursorPosition++;
                    this.renderNanoContent();
                    event.preventDefault();
                    return;
                }
                if (event.key === 'Backspace') {
                    if (this.cursorPosition > 0) {
                        this.editingContent = this.editingContent.slice(0, this.cursorPosition - 1) + this.editingContent.slice(this.cursorPosition);
                        this.cursorPosition--;
                        this.renderNanoContent();
                    }
                    event.preventDefault();
                    return;
                }
                if (event.key === 'ArrowLeft') {
                    if (this.cursorPosition > 0) {
                        this.cursorPosition--;
                        this.renderNanoContent();
                    }
                    event.preventDefault();
                    return;
                }
                if (event.key === 'ArrowRight') {
                    if (this.cursorPosition < this.editingContent.length) {
                        this.cursorPosition++;
                        this.renderNanoContent();
                    }
                    event.preventDefault();
                    return;
                }
                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    // Optionally handle up/down
                    event.preventDefault();
                    return;
                }
                if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
                    this.editingContent = this.editingContent.slice(0, this.cursorPosition) + event.key + this.editingContent.slice(this.cursorPosition);
                    this.cursorPosition++;
                    this.renderNanoContent();
                    event.preventDefault();
                    return;
                }
            }

            renderNanoContent() {
                this.element.innerHTML = ''; // Clear the terminal

                // Display the file content with cursor
                const contentBeforeCursor = this.editingContent.slice(0, this.cursorPosition).replace(/\n/g, '<br>');
                const contentAfterCursor = this.editingContent.slice(this.cursorPosition).replace(/\n/g, '<br>');
                const contentWithCursor = contentBeforeCursor + '<span class="nano-cursor">â–ˆ</span>' + contentAfterCursor;

                const contentElement = document.createElement('div');
                contentElement.innerHTML = contentWithCursor;
                this.element.appendChild(contentElement);

                // Status bar
                const statusBar = document.createElement('div');
                statusBar.style.backgroundColor = '#444';
                statusBar.style.color = '#fff';
                statusBar.textContent = `File: ${this.editingFile}`;
                this.element.appendChild(statusBar);

                // Command shortcuts
                const shortcutsBar = document.createElement('div');
                shortcutsBar.style.backgroundColor = '#222';
                shortcutsBar.style.color = '#fff';

                // Create clickable elements for WriteOut and Exit
                const writeOut = document.createElement('span');
                writeOut.textContent = '^O WriteOut';
                writeOut.style.cursor = 'pointer';
                writeOut.addEventListener('click', () => this.saveNanoFile());

                const exit = document.createElement('span');
                exit.textContent = '^X Exit';
                exit.style.cursor = 'pointer';
                exit.addEventListener('click', () => this.exitNano());

                // Add some spacing between the clickable elements
                shortcutsBar.appendChild(writeOut);
                shortcutsBar.appendChild(document.createTextNode('   ')); // Add space
                shortcutsBar.appendChild(exit);

                this.element.appendChild(shortcutsBar);

                this.element.scrollTop = this.element.scrollHeight;

                // Focus the terminal to capture key events
                this.element.focus();
            }

            saveNanoFile() {
                this.currentDirectory.children[this.editingFile].content = this.editingContent;
                this.saveFileSystem();
                this.printLine(`\nFile '${this.editingFile}' saved.`);
                this.newPrompt();
            }

            exitNano() {
                this.isEditing = false;
                this.editingFile = null;
                this.editingContent = '';
                this.cursorPosition = 0;
                this.newPrompt();
            }

            executeCommand(commandLine) {
                const args = this.parseArgs(commandLine);
                if (args.length === 0) {
                    this.newPrompt();
                    return;
                }
                const command = args[0];
                const params = args.slice(1);
                this.runCommand(command, params);
            }

            parseArgs(commandLine) {
                const args = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < commandLine.length; i++) {
                    const char = commandLine[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                        continue;
                    }
                    if (char === ' ' && !inQuotes) {
                        if (current.length > 0) {
                            args.push(current);
                            current = '';
                        }
                        continue;
                    }
                    current += char;
                }
                if (current.length > 0) {
                    args.push(current);
                }
                return args;
            }

            runCommand(command, params) {
                switch (command) {
                    case 'help':
                        this.help(params);
                        break;
                    case 'ls':
                        this.ls(params);
                        break;
                    case 'cd':
                        this.cd(params);
                        break;
                    case 'mkdir':
                        this.mkdir(params);
                        break;
                    case 'touch':
                        this.touch(params);
                        break;
                    case 'rm':
                        this.rm(params);
                        break;
                    case 'cat':
                        this.cat(params);
                        break;
                    case 'node':
                        this.nodeCommand(params);
                        break;
                    case 'nano':
                        this.nano(params);
                        break;
                    case 'mv':
                        this.mv(params);
                        break;
                    default:
                        this.printLine(`Command not found: ${command}`);
                        this.newPrompt();
                }
            }

            nano(params) {
                if (params.length < 1) {
                    this.printLine("Usage: nano <filename>");
                    this.newPrompt();
                    return;
                }
                const filename = params[0];
                const file = this.currentDirectory.children[filename];
                if (!file || file.type !== 'file') {
                    this.printLine(`File not found: ${filename}`);
                    this.newPrompt();
                    return;
                }
                this.isEditing = true;
                this.editingFile = filename;
                this.editingContent = file.content;
                this.cursorPosition = this.editingContent.length;
                this.renderNanoContent();
            }

            help(params) {
                if (params.length === 0) {
                    this.printLine("Possible commands:");
                    this.printLine("help - Display help information");
                    this.printLine("ls - List directory contents");
                    this.printLine("cd - Change the current directory");
                    this.printLine("mkdir - Create a new directory");
                    this.printLine("touch - Create a new file");
                    this.printLine("rm - Remove a file or directory");
                    this.printLine("cat - Display file contents");
                    this.printLine("nano - Edit a file");
                    this.printLine("node - Execute a node command");
                    this.printLine("mv - Move a file or directory");
                    this.newPrompt();
                } else {
                    const cmd = params[0];
                    switch (cmd) {
                        case 'help':
                            this.printLine("help [command] - Display help information");
                            break;
                        case 'ls':
                            this.printLine("ls - List directory contents");
                            break;
                        case 'cd':
                            this.printLine("cd [directory] - Change the current directory");
                            break;
                        case 'mkdir':
                            this.printLine("mkdir <directory> - Create a new directory");
                            break;
                        case 'touch':
                            this.printLine("touch <file> - Create a new file");
                            break;
                        case 'rm':
                            this.printLine("rm <file|directory> - Remove a file or directory");
                            break;
                        case 'cat':
                            this.printLine("cat <file> - Display file contents");
                            break;
                        case 'nano':
                            this.printLine("nano <file> - Edit a file");
                            break;
                        case 'node':
                            this.printLine("node . <command> <args> - Execute a node command");
                            break;
                        case 'mv':
                            this.printLine("mv <source> <destination> - Move a file or directory");
                            break;
                        default:
                            this.printLine(`No help available for ${cmd}`);
                    }
                    this.newPrompt();
                }
            }

            ls() {
                if (this.currentDirectory && this.currentDirectory.children) {
                    const children = Object.keys(this.currentDirectory.children);
                    if (children.length > 0) {
                        this.printLine(children.join('    '));
                    } else {
                        this.printLine("Directory is empty.");
                    }
                } else {
                    this.printLine("Error: Unable to list contents.");
                }
                this.newPrompt();
            }

            cd(params) {
                if (params.length === 0 || params[0] === "..") {
                    const pathParts = this.promptPath.split('/').filter(part => part);

                    if (pathParts.length > 1) {
                        pathParts.pop();
                        this.promptPath = '/' + pathParts.join('/');
                        this.currentDirectory = this.getDirectory(this.promptPath);
                    } else {
                        this.printLine("Already at the root directory.");
                    }
                } else {
                    const target = params[0];
                    if (target === '/') {
                        this.currentDirectory = this.fileSystem.root;
                        this.promptPath = '/root';
                    } else if (this.currentDirectory.children && this.currentDirectory.children[target]) {
                        const targetDir = this.currentDirectory.children[target];
                        if (targetDir.type === 'directory') {
                            this.currentDirectory = targetDir;
                            this.promptPath += `/${target}`;
                        } else {
                            this.printLine(`${target}: Not a directory`);
                        }
                    } else {
                        this.printLine(`cd: no such file or directory: ${target}`);
                    }
                }
                this.newPrompt();
            }

            mkdir(params) {
                if (params.length === 0) {
                    this.printLine("mkdir: missing operand");
                    this.newPrompt();
                    return;
                }
                const dirName = params[0];
                if (this.currentDirectory.children[dirName]) {
                    this.printLine(`mkdir: cannot create directory '${dirName}': File exists`);
                } else {
                    this.currentDirectory.children[dirName] = {
                        type: 'directory',
                        children: {}
                    };
                    this.saveFileSystem();
                    this.printLine(`Directory '${dirName}' created.`);
                }
                this.newPrompt();
            }

            touch(params) {
                if (params.length === 0) {
                    this.printLine("touch: missing file operand");
                    this.newPrompt();
                    return;
                }
                const fileName = params[0];
                if (this.currentDirectory.children[fileName]) {
                    this.printLine(`touch: cannot create file '${fileName}': File exists`);
                } else {
                    this.currentDirectory.children[fileName] = {
                        type: 'file',
                        content: ''
                    };
                    this.saveFileSystem();
                    this.printLine(`File '${fileName}' created.`);
                }
                this.newPrompt();
            }

            rm(params) {
                if (params.length === 0) {
                    this.printLine("rm: missing operand");
                    this.newPrompt();
                    return;
                }
                const target = params[0];
                if (this.currentDirectory.children && this.currentDirectory.children[target]) {
                    delete this.currentDirectory.children[target];
                    this.saveFileSystem();
                    this.printLine(`${target} removed.`);
                } else {
                    this.printLine(`rm: cannot remove '${target}': No such file or directory`);
                }
                this.newPrompt();
            }

            cat(params) {
                if (params.length === 0) {
                    this.printLine("cat: missing file operand");
                    this.newPrompt();
                    return;
                }
                const fileName = params[0];
                if (this.currentDirectory.children && this.currentDirectory.children[fileName]) {
                    const file = this.currentDirectory.children[fileName];
                    if (file.type === 'file') {
                        this.printLine(file.content || "");
                    } else {
                        this.printLine(`cat: ${fileName}: Is a directory`);
                    }
                } else {
                    this.printLine(`cat: ${fileName}: No such file or directory`);
                }
                this.newPrompt();
            }

            nodeCommand(params) {
                if (params.length < 1) {
                    this.printLine("node: missing arguments");
                    this.newPrompt();
                    return;
                }
                if (params[0] !== '.') {
                    this.printLine("node: only support 'node .' commands");
                    this.newPrompt();
                    return;
                }
                if (params.length < 2) {
                    this.printLine("node: missing command");
                    this.newPrompt();
                    return;
                }
                const func = params[1];
                const subFunc = params[2] || '';
                const args = params.slice(3);

                // Simulate node commands related to doginals.py
                switch (func) {
                    case 'wallet':
                        this.handleWalletCommand(subFunc, args);
                        break;
                    case 'drc-20':
                        this.handleDrc20Command(subFunc, args);
                        break;
                    case 'mint':
                        this.handleMintCommand(args);
                        break;
                    case 'server':
                        this.handleServerCommand();
                        break;
                    default:
                        this.printLine(`Executing node . ${func} ${subFunc} ${args.join(' ')}`);
                        this.newPrompt();
                }
            }

            // Simulate wallet-related commands
            handleWalletCommand(subFunc, args) {
                switch (subFunc) {
                    case 'new':
                        if (args.length < 1) {
                            this.printLine("Usage: node . wallet new <name of the new wallet>");
                            this.newPrompt();
                            break;
                        }

                        const walletName = args[0];
                        const doginalsMainDir = this.fileSystem.root.children['doginals-main'];
                        
                        // Ensure doginals-main directory exists
                        if (!doginalsMainDir || doginalsMainDir.type !== 'directory') {
                            this.printLine("Error: /root/doginals-main directory not found.");
                            this.newPrompt();
                            break;
                        }

                        // Check for or create the wallets directory
                        if (!doginalsMainDir.children['wallets']) {
                            doginalsMainDir.children['wallets'] = {
                                type: 'directory',
                                children: {}
                            };
                        }
                        
                        const walletsDir = doginalsMainDir.children['wallets'];

                        // Check if the wallet file already exists
                        if (walletsDir.children[`${walletName}.json`]) {
                            this.printLine(`Error: Wallet '${walletName}' already exists.`);
                            this.newPrompt();
                            break;
                        }

                        // Make a POST request to the Flask endpoint to create a new wallet
                        fetch('/wallet/new', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        })
                        .then(response => response.json())
                        .then(data => {
                            // Extract privkey and address from data.stdout using regex
                            const privkeyMatch = data.stdout.match(/Private Key: (\w+)/);
                            const addressMatch = data.stdout.match(/Address: (\w+)/);

                            if (!privkeyMatch || !addressMatch) {
                                this.printLine("Error: Unable to parse 'privkey' or 'address' from response.");
                                this.newPrompt();
                                return;
                            }

                            const privkey = privkeyMatch[1];
                            const address = addressMatch[1];

                            // Create a wallet file with the retrieved data
                            walletsDir.children[`${walletName}.json`] = {
                                type: 'file',
                                content: JSON.stringify({
                                    privkey: privkey,
                                    address: address,
                                    utxos: []
                                }, null, 2) // Pretty-print JSON content
                            };

                            // Save to localStorage
                            this.saveFileSystem();

                            // Print the wallet creation details
                            this.printLine("Wallet created successfully.");
                            this.printLine(`stdout: ${data.stdout}`);
                            this.printLine(JSON.stringify({
                                privkey: privkey,
                                address: address,
                                utxos: []
                            }, null, 2));
                            this.newPrompt();
                        })
                        .catch(error => {
                            this.printLine(`Error: ${error}`);
                            this.newPrompt();
                        });
                        break;

                    case 'sync':
                        if (args[0]) {
                            fetch('/wallet/sync', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ wallet_address: args[0] })
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.stdout) {
                                    this.printLine(`stdout: ${data.stdout}`);
                                }
                                if (data.stderr) {
                                    this.printLine(`stderr: ${data.stderr}`);
                                }
                                this.newPrompt();
                            })
                            .catch(error => {
                                this.printLine(`Error: ${error}`);
                                this.newPrompt();
                            });
                        } else {
                            this.printLine("Usage: node . wallet sync <wallet_address>");
                            this.newPrompt();
                        }
                        break;
                    case 'send':
                        if (args.length >= 4) {
                            fetch('/wallet/send', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    recipient_address: args[0],
                                    amount: args[1],
                                    utxos: args[2],
                                    private_key: args[3]
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                this.printLine(`stdout: ${data.stdout}`);
                                this.newPrompt();
                            })
                            .catch(error => {
                                this.printLine(`Error: ${error}`);
                                this.newPrompt();
                            });
                        } else {
                            this.printLine("Usage: node . wallet send <recipient_address> <amount> <utxos> <private_key>");
                            this.newPrompt();
                        }
                        break;
                    case 'split':
                        if (args.length >= 3) {
                            fetch('/wallet/split', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    number_of_splits: args[0],
                                    utxos: args[1],
                                    private_key: args[2]
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                this.printLine(`stdout: ${data.stdout}`);
                                this.newPrompt();
                            })
                            .catch(error => {
                                this.printLine(`Error: ${error}`);
                                this.newPrompt();
                            });
                        } else {
                            this.printLine("Usage: node . wallet split <number_of_splits> <utxos> <private_key>");
                            this.newPrompt();
                        }
                        break;
                    case 'brocastraw':
                        if (args[0]) {
                            fetch('/wallet/brocastraw', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ raw_transaction_hex: args[0] })
                            })
                            .then(response => response.json())
                            .then(data => {
                                this.printLine(`stdout: ${data.stdout}`);
                                this.newPrompt();
                            })
                            .catch(error => {
                                this.printLine(`Error: ${error}`);
                                this.newPrompt();
                            });
                        } else {
                            this.printLine("Usage: node . wallet brocastraw <raw_transaction_hex>");
                            this.newPrompt();
                        }
                        break;
                    default:
                        this.printLine(`Unknown wallet command: ${subFunc}`);
                        this.newPrompt();
                }
            }

            // Simulate DRC-20 token commands
            handleDrc20Command(subFunc, args) {
                switch (subFunc) {
                    case 'deploy':
                        if (args.length >= 4) {
                            fetch('/drc-20/deploy', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    address: args[0],
                                    ticker: args[1],
                                    max: args[2],
                                    limit: args[3]
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                this.printLine(`stdout: ${data.stdout}`);
                                this.newPrompt();
                            })
                            .catch(error => {
                                this.printLine(`Error: ${error}`);
                                this.newPrompt();
                            });
                        } else {
                            this.printLine("Usage: node . drc-20 deploy <address> <ticker> <max> <limit>");
                            this.newPrompt();
                        }
                        break;
                    case 'mint':
                        if (args.length >= 4) {
                            fetch('/drc-20/mint', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    address: args[0],
                                    ticker: args[1],
                                    amount: args[2],
                                    repeat: args[3]
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                this.printLine(`stdout: ${data.stdout}`);
                                this.newPrompt();
                            })
                            .catch(error => {
                                this.printLine(`Error: ${error}`);
                                this.newPrompt();
                            });
                        } else {
                            this.printLine("Usage: node . drc-20 mint <address> <ticker> <amount> <repeat>");
                            this.newPrompt();
                        }
                        break;
                    default:
                        this.printLine(`Unknown DRC-20 command: ${subFunc}`);
                        this.newPrompt();
                }
            }

            // Simulate minting inscriptions
            handleMintCommand(args) {
                if (args.length >= 3) {
                    fetch('/mint', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            recipient_address: args[0],
                            content_type_or_filename: args[1],
                            hex_data: args[2],
                            utxos: args[3] || '',
                            private_key: args[4] || ''
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        this.printLine(`stdout: ${data.stdout}`);
                        this.newPrompt();
                    })
                    .catch(error => {
                        this.printLine(`Error: ${error}`);
                        this.newPrompt();
                    });
                } else {
                    this.printLine("Usage: node . mint <recipient_address> <content_type_or_filename> <hex_data> <utxos> <private_key>");
                    this.newPrompt();
                }
            }

            // Simulate starting a server
            handleServerCommand() {
                this.printLine("Server started at http://localhost:3000/tx/15f3b73df7e5c072becb1d84191843ba080734805addfccb650929719080f62e");
                this.newPrompt();
            }

            mv(params) {
                if (params.length < 2) {
                    this.printLine("Usage: mv <source> <destination>");
                    this.newPrompt();
                    return;
                }

                const source = params[0];
                const destination = params[1];

                const sourceFile = this.currentDirectory.children[source];
                if (!sourceFile) {
                    this.printLine(`mv: cannot stat '${source}': No such file or directory`);
                    this.newPrompt();
                    return;
                }

                const destinationDir = this.currentDirectory.children[destination];
                if (!destinationDir || destinationDir.type !== 'directory') {
                    this.printLine(`mv: target '${destination}' is not a directory`);
                    this.newPrompt();
                    return;
                }

                // Move the file or directory
                destinationDir.children[source] = sourceFile;
                delete this.currentDirectory.children[source];
                this.saveFileSystem();
                this.printLine(`'${source}' moved to '${destination}'`);
                this.newPrompt();
            }

            getDirectory(path) {
                const parts = path.split('/').filter(part => part);
                let dir = this.fileSystem.root;
                for (const part of parts.slice(1)) { // Skip 'root'
                    if (dir.children && dir.children[part]) {
                        dir = dir.children[part];
                    } else {
                        return null;
                    }
                }
                return dir;
            }

            printLine(text) {
                const line = document.createElement('div');
                line.textContent = text;
                this.element.appendChild(line);
                this.element.scrollTop = this.element.scrollHeight;
            }
        }

        // Initialize Terminal
        const terminalElement = document.getElementById('terminal');
        const terminal = new Terminal(terminalElement);
    </script>
</body>
</html>
